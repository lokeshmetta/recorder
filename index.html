<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>High-Quality Screen Recorder (Enhanced)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'montserrat', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #6cc1b8 0%, #dcb277 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 640px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 15px;
            font-size: 2em;
            font-weight: 400;
        }

        .quality-settings {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 10px;
        }

        .quality-settings h3 {
            margin-bottom: 10px;
            color: #495057;
        }

        .setting-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            gap: 5px;
        }

        select,
        input[type="number"] {
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            min-width: 140px;
        }

        .toggles {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-bottom: 20px;
        }

        .toggle {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .toggle.disabled {
            opacity: 0.6;
            background: #e9ecef;
        }

        .btn {
            padding: 14px 22px;
            font-size: 16px;
            font-weight: 400;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.6px;
            min-width: 160px;
            margin: 5px;
        }

        .btn-start {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }

        .btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(40, 167, 69, 0.3);
        }

        .btn-stop {
            background: linear-gradient(45deg, #dc3545, #e83e8c);
            color: white;
        }

        .btn-stop:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(220, 53, 69, 0.3);
        }

        .btn-pause {
            background: linear-gradient(45deg, #ffc107, #ff9800);
            color: white;
        }

        .btn-resume {
            background: linear-gradient(45deg, #17a2b8, #20c997);
            color: white;
        }

        .btn-pause:hover,
        .btn-resume:hover {
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            margin: 16px 0;
            padding: 12px;
            border-radius: 10px;
            font-weight: 500;
            color: white;
        }

        .status.ready {
            background: linear-gradient(45deg, #20bf6b, #0fb9b1);
        }

        .status.recording {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            animation: pulse 1.5s infinite;
        }

        .status.stopped {
            background: linear-gradient(45deg, #3742fa, #2f3542);
        }

        .status.paused {
            background: linear-gradient(45deg, #ffc107, #ff9800);
        }

        .status.warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1
            }

            50% {
                opacity: .75
            }
        }

        .timer {
            font-size: 1.6em;
            font-weight: bold;
            color: #333;
            margin: 10px 0 18px;
            font-family: 'Courier New', monospace;
        }

        .preview-container {
            margin-top: 20px;
            display: none;
        }

        .preview-video {
            width: 100%;
            max-width: 520px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            margin-bottom: 14px;
        }

        .download-section {
            display: flex;
            gap: 12px;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .btn-download {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-convert {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }

        .file-info {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            color: #6c757d;
            margin-bottom: 10px;
        }

        .error {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 12px;
            border-radius: 10px;
            margin: 14px 0;
            display: none;
        }

        .warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
            padding: 12px;
            border-radius: 10px;
            margin: 14px 0;
            display: none;
        }

        .note {
            font-size: 12px;
            color: #555;
            margin-top: 8px;
        }

        .device-info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 14px;
            text-align: left;
            display: none;
        }

        .conversion-progress {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s ease;
        }

        .visualizer-container {
            margin-bottom: 20px;
        }

        #micVisualizer {
            width: 100%;
            height: 60px;
            background: #f0f2f5;
            border-radius: 10px;
            display: none;
            /* Hidden by default */
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>🎥 Screen Recorder</h1>

        <div class="quality-settings">
            <h3>Quality Settings</h3>
            <div class="setting-group">
                <label for="recordingFormat">Recording Format:</label>
                <select id="recordingFormat" title="Select recording format">
                    <option value="webm" selected>WebM (Recommended)</option>
                    <option value="mp4" title="MP4 (Browser Support Varies)">MP4 (Browser Support Varies)</option>
                </select>
            </div>
            <div class="setting-group">
                <label>Video Quality:</label>
                <select id="videoQuality">
                    <option value="1080p" selected>1080p (1920x1080)</option>
                    <option value="720p">720p (1280x720)</option>
                    <option value="480p" title="480p (854x480)">480p (854x480)</option>
                    <option value="4k">4K (3840x2160)</option>
                    <option value="auto">Auto (match source)</option>
                </select>
            </div>
            <div class="setting-group">
                <label>Frame Rate:</label>
                <select id="frameRate">
                    <option value="60" selected title="60 Frames Per Second">60 FPS</option>
                    <option value="30">30 FPS</option>
                    <option value="24">24 FPS</option>
                    <option value="15">15 FPS</option>
                </select>
            </div>
            <div class="setting-group">
                <label>Video Bitrate (kbps):</label>
                <input type="number" id="bitrate" value="5000" min="1000" max="50000" step="500"
                    title="Set video bitrate in kilobits per second">
            </div>
            <div id="bitrateNote" class="note" style="text-align: right; margin-top: -5px; margin-bottom: 10px;"></div>
        </div>

        <div class="toggles">
            <label class="toggle" id="micToggle"><input type="checkbox" id="withMic" checked
                    title="Record audio from your microphone"> Record microphone</label>
            <div class="setting-group">
                <label for="micSelect">Microphone:</label>
                <select id="micSelect" style="max-width: 200px;" title="Select microphone device"></select>
            </div>
            <label class="toggle"><input type="checkbox" id="withSysAudio" checked
                    title="Attempt to record system or tab audio"> Try system/tab audio</label>
            <label class="toggle"><input type="checkbox" id="voiceHPF" checked
                    title="Apply a high-pass filter to microphone audio to reduce low-frequency noise"> Voice high‑pass
                filter</label>
            <label class="toggle"><input type="checkbox" id="noSmoothing" checked
                    title="Disable image smoothing for pixel-perfect recordings"> Disable image smoothing</label>
        </div>

        <div class="visualizer-container">
            <canvas id="micVisualizer"></canvas>
        </div>

        <div id="deviceInfo" class="device-info"></div>
        <div id="warningMessage" class="warning"></div>

        <div>
            <button id="startBtn" class="btn btn-start">Start Recording</button>
            <button id="pauseBtn" class="btn btn-pause" style="display: none;">Pause</button>
            <button id="resumeBtn" class="btn btn-resume" style="display: none;">Resume</button>
            <button id="stopBtn" class="btn btn-stop" style="display: none;">Stop Recording</button>
        </div>

        <div id="status" class="status ready">Ready to record</div>
        <div id="timer" class="timer">00:00</div>
        <div id="errorMessage" class="error"></div>

        <div id="conversionProgress" class="conversion-progress">
            <div>Converting to MP4...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText">0%</div>
        </div>

        <div id="previewContainer" class="preview-container">
            <video id="previewVideo" class="preview-video" controls></video>
            <div id="fileInfo" class="file-info"></div>
            <div class="download-section">
                <button id="downloadBtn" class="btn btn-download">Download WebM</button>
                <button id="convertBtn" class="btn btn-convert">Convert & Download MP4</button>
            </div>
            <div class="note">
                WebM offers better compression and quality. MP4 conversion uses WebAssembly FFmpeg for broader
                compatibility.
            </div>
        </div>
    </div>

    <!-- FFmpeg WebAssembly for MP4 conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ffmpeg/0.11.6/ffmpeg.min.js"></script>

    <script>
        class ScreenRecorderPro {
            constructor() {
                this.displayStream = null;
                this.micStream = null;
                this.mixedStream = null;
                this.mediaRecorder = null;
                this.chunks = [];
                this.audioCtx = null;
                this.destination = null;
                this.timerInterval = null;
                this.startTime = 0;
                this.elapsedTimeInSeconds = 0;
                this.recordedBlob = null;
                this.ffmpeg = null;
                this.microphoneAvailable = false;
                this.isMobileDevice = this.isMobile();
                this.analyser = null;
                this.visualizerFrame = null;

                this.initElements();
                this.checkDeviceCapabilities();
                this.bindEvents();
                this.initFFmpeg();
                this.updateRecommendedBitrate();
            }

            isMobile() {
                // A simple check for mobile user agents.
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            initElements() {
                this.recordingFormat = document.getElementById('recordingFormat');
                this.videoQuality = document.getElementById('videoQuality');
                this.frameRate = document.getElementById('frameRate');
                this.bitrate = document.getElementById('bitrate');
                this.bitrateNote = document.getElementById('bitrateNote');
                this.withMic = document.getElementById('withMic');
                this.micToggle = document.getElementById('micToggle');
                this.micSelect = document.getElementById('micSelect');
                this.withSysAudio = document.getElementById('withSysAudio');
                this.voiceHPF = document.getElementById('voiceHPF');
                this.noSmoothing = document.getElementById('noSmoothing');
                this.micVisualizer = document.getElementById('micVisualizer');

                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.resumeBtn = document.getElementById('resumeBtn');
                this.status = document.getElementById('status');
                this.timer = document.getElementById('timer');
                this.errorMessage = document.getElementById('errorMessage');
                this.warningMessage = document.getElementById('warningMessage');
                this.deviceInfo = document.getElementById('deviceInfo');
                this.previewContainer = document.getElementById('previewContainer');
                this.previewVideo = document.getElementById('previewVideo');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.convertBtn = document.getElementById('convertBtn');
                this.fileInfo = document.getElementById('fileInfo');
                this.conversionProgress = document.getElementById('conversionProgress');
                this.progressFill = document.getElementById('progressFill');
                this.progressText = document.getElementById('progressText');
            }

            async checkDeviceCapabilities() {
                // Mobile device check
                if (this.isMobileDevice) {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                        this.showError('Screen recording is not supported on your mobile browser. Please try on a desktop computer.');
                        this.startBtn.disabled = true;
                        this.startBtn.textContent = 'Unsupported on Mobile';
                        this.startBtn.style.background = '#6c757d';
                    } else {
                        this.showWarning('Mobile screen recording is experimental and may not work reliably.');
                    }
                }

                // Check for MP4 recording support
                const mp4Option = this.recordingFormat.querySelector('option[value="mp4"]');
                if (!MediaRecorder.isTypeSupported('video/mp4')) {
                    mp4Option.disabled = true;
                    mp4Option.textContent = 'MP4 (Not Supported)';
                }

                try {
                    // Check microphone availability
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const audioInputDevices = devices.filter(device => device.kind === 'audioinput');
                    this.microphoneAvailable = audioInputDevices.length > 0;

                    if (!this.microphoneAvailable) {
                        this.withMic.checked = false;
                        this.withMic.disabled = true;
                        this.micToggle.classList.add('disabled');
                        this.micSelect.disabled = true;
                        this.showDeviceInfo('⚠️ No microphone detected. Audio recording will use system/tab audio only.');
                    } else {
                        this.showDeviceInfo('🎤 Microphone available for recording.');
                        this.populateMicSelect(audioInputDevices);
                        this.initMicVisualizer();
                    }

                } catch (err) {
                    console.warn('Could not enumerate devices:', err);
                    this.showWarning('Could not detect available devices. Some features may not work properly.');
                }
            }

            populateMicSelect(devices) {
                this.micSelect.innerHTML = '';
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Microphone ${this.micSelect.options.length + 1}`;
                    this.micSelect.appendChild(option);
                });
            }

            async initMicVisualizer() {
                if (!this.withMic.checked) return;

                try {
                    if (this.micStream) {
                        this.micStream.getTracks().forEach(track => track.stop());
                    }

                    this.micStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            deviceId: { exact: this.micSelect.value },
                            noiseSuppression: true,
                            echoCancellation: true
                        }
                    });

                    if (!this.audioCtx) {
                        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const source = this.audioCtx.createMediaStreamSource(this.micStream);
                    this.setupVisualizer(source);

                } catch (err) {
                    this.showWarning('Could not access microphone for visualizer.');
                }
            }

            async initFFmpeg() {
                try {
                    if (typeof FFmpeg !== 'undefined') {
                        const { createFFmpeg, fetchFile } = FFmpeg;
                        this.ffmpeg = createFFmpeg({
                            log: false,
                            corePath: 'https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js'
                        });
                    }
                } catch (err) {
                    console.warn('FFmpeg initialization failed:', err);
                    this.convertBtn.style.display = 'none';
                }
            }

            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
                this.pauseBtn.addEventListener('click', () => this.pauseRecording());
                this.resumeBtn.addEventListener('click', () => this.resumeRecording());
                this.downloadBtn.addEventListener('click', () => {
                    if (!this.recordedBlob) return;
                    const extension = this.recordedBlob.type.includes('mp4') ? 'mp4' : 'webm';
                    this.downloadRecording(extension);
                });
                this.convertBtn.addEventListener('click', () => this.convertAndDownload());

                this.videoQuality.addEventListener('change', () => this.updateRecommendedBitrate());
                this.frameRate.addEventListener('change', () => this.updateRecommendedBitrate());

                // Update microphone settings when checkbox changes
                this.withMic.addEventListener('change', () => {
                    if (this.withMic.checked && !this.microphoneAvailable) {
                        this.withMic.checked = false;
                        this.showWarning('No microphone available on this device.');
                    } else if (this.withMic.checked) {
                        this.micSelect.disabled = false;
                        this.initMicVisualizer();
                    } else {
                        if (this.micStream) {
                            this.micStream.getTracks().forEach(track => track.stop());
                            this.micStream = null;
                        }
                        if (this.visualizerFrame) {
                            cancelAnimationFrame(this.visualizerFrame);
                        }
                        this.micVisualizer.style.display = 'none';
                        this.micSelect.disabled = true;
                    }
                });

                this.micSelect.addEventListener('change', () => {
                    this.initMicVisualizer();
                });
            }

            updateRecommendedBitrate() {
                const quality = this.videoQuality.value;
                const fps = this.frameRate.value;

                // A map of bitrates (in kbps) for different quality/fps combinations
                // These are good starting points for high-quality VP9/H.264 encoding.
                const bitrateMap = {
                    '4k': { '60': 40000, '30': 25000, '24': 20000, '15': 15000 },
                    '1080p': { '60': 12000, '30': 8000, '24': 6000, '15': 4000 },
                    '720p': { '60': 7500, '30': 5000, '24': 4000, '15': 2500 },
                    '480p': { '60': 4000, '30': 2500, '24': 2000, '15': 1500 }
                };

                if (quality === 'auto') {
                    this.bitrate.value = 8000; // A sensible default for 'auto'
                    this.bitrateNote.textContent = 'Bitrate for "Auto" is a general default. Adjust manually.';
                    return;
                }

                const recommendedBitrate = bitrateMap[quality]?.[fps] || 5000;
                this.bitrate.value = recommendedBitrate;
                this.bitrateNote.textContent = 'Recommended value based on quality and FPS.';
            }

            getDisplayConstraints() {
                const choice = this.videoQuality.value;
                const fps = parseInt(this.frameRate.value, 10);

                // For mobile, use simpler constraints to maximize compatibility.
                // Mobile browsers often ignore detailed constraints for screen capture.
                if (this.isMobileDevice) {
                    return {
                        video: {
                            frameRate: { ideal: fps, max: fps },
                        },
                        audio: this.withSysAudio.checked ? true : false
                    };
                }

                const map = {
                    '480p': { width: { ideal: 854 }, height: { ideal: 480 } },
                    '720p': { width: { ideal: 1280 }, height: { ideal: 720 } },
                    '1080p': { width: { ideal: 1920 }, height: { ideal: 1080 } },
                    '4k': { width: { ideal: 3840 }, height: { ideal: 2160 } },
                    'auto': {}
                };
                const dims = map[choice] || {};
                return {
                    video: {
                        frameRate: { ideal: fps, max: fps },
                        displaySurface: 'monitor',
                        ...dims
                    },
                    audio: this.withSysAudio.checked ? true : false
                };
            }

            async startRecording() {
                try {
                    this.hideMessages();
                    this.disableUIOnStart();

                    this.elapsedTimeInSeconds = 0;
                    this.timer.textContent = '00:00';
                    // 1) Get display stream
                    this.displayStream = await navigator.mediaDevices.getDisplayMedia(this.getDisplayConstraints());

                    const dispTrack = this.displayStream.getVideoTracks()[0];
                    dispTrack.addEventListener('ended', () => {
                        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                            this.stopRecording();
                        }
                    });

                    // 2) Get microphone stream if not already available
                    if (this.withMic.checked && this.microphoneAvailable && !this.micStream) {
                        try {
                            this.micStream = await navigator.mediaDevices.getUserMedia({
                                audio: {
                                    deviceId: { exact: this.micSelect.value },
                                    channelCount: 1,
                                    sampleRate: 48000,
                                    noiseSuppression: true,
                                    echoCancellation: true,
                                    autoGainControl: true
                                }
                            });
                        } catch (micError) {
                            console.warn('Microphone access failed:', micError);
                            this.showWarning('Microphone access failed. Recording will continue without microphone audio.');
                            this.micStream = null;
                        }
                    }

                    // 3) Mix audio streams
                    const audioInputs = [];
                    if (this.withSysAudio.checked && this.displayStream.getAudioTracks().length > 0) {
                        audioInputs.push(new MediaStream(this.displayStream.getAudioTracks()));
                    }
                    if (this.micStream) {
                        audioInputs.push(this.micStream);
                    }

                    let finalStream;
                    if (audioInputs.length > 0) {
                        try {
                            if (!this.audioCtx) {
                                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                            }
                            this.destination = this.audioCtx.createMediaStreamDestination();

                            const merger = this.audioCtx.createGain();
                            merger.gain.value = 1.0;

                            audioInputs.forEach((stream) => {
                                const source = this.audioCtx.createMediaStreamSource(stream);
                                const gainNode = this.audioCtx.createGain();
                                const isMicStream = (this.micStream && stream === this.micStream);
                                gainNode.gain.value = isMicStream ? 1.0 : 0.85;

                                if (isMicStream) {
                                    if (!this.analyser) this.setupVisualizer(source);
                                    if (this.voiceHPF.checked) {
                                        const highpass = this.audioCtx.createBiquadFilter();
                                        highpass.type = 'highpass';
                                        highpass.frequency.value = 90;
                                        source.connect(highpass).connect(gainNode).connect(merger);
                                    } else {
                                        source.connect(gainNode).connect(merger);
                                    }
                                } else {
                                    source.connect(gainNode).connect(merger);
                                }
                            });

                            merger.connect(this.destination);
                            finalStream = new MediaStream([
                                ...this.displayStream.getVideoTracks(),
                                ...this.destination.stream.getAudioTracks()
                            ]);
                        } catch (audioError) {
                            console.warn('Audio mixing failed:', audioError);
                            finalStream = this.displayStream;
                            this.showWarning('Audio mixing failed. Using display stream only.');
                        }
                    } else {
                        finalStream = this.displayStream;
                    }

                    this.mixedStream = finalStream;

                    // 4) Setup MediaRecorder with improved codec selection
                    const bitrate = Math.max(1000, parseInt(this.bitrate.value, 10) || 5000);
                    const mimeType = this.selectBestMimeType();
                    if (!mimeType) {
                        this.showError('No supported video format found for recording.');
                        this.enableUIIdle();
                        this.cleanup();
                        return;
                    }

                    const options = {
                        mimeType: mimeType,
                        videoBitsPerSecond: bitrate * 1000,
                        audioBitsPerSecond: 128000 // Lowered for Opus
                    };

                    this.mediaRecorder = new MediaRecorder(this.mixedStream, options);
                    this.chunks = [];

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data && event.data.size > 0) {
                            this.chunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => this.handleStop();
                    this.mediaRecorder.onerror = (event) => {
                        this.showError('Recording error: ' + event.error);
                        this.stopRecording();
                    };

                    // 5) Start recording
                    this.mediaRecorder.start(1000); // 1s chunks for better stability
                    this.startTimer();
                    this.updateStatus('🔴 Recording in progress...', 'recording');

                } catch (err) {
                    this.showError('Failed to start recording: ' + (err.message || err));
                    this.enableUIIdle();
                    this.cleanup();
                }
            }

            setupVisualizer(micSource) {
                this.micVisualizer.style.display = 'block';
                this.analyser = this.audioCtx.createAnalyser();
                this.analyser.fftSize = 256;
                micSource.connect(this.analyser);

                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                const canvasCtx = this.micVisualizer.getContext('2d');

                const draw = () => {
                    this.visualizerFrame = requestAnimationFrame(draw);

                    this.analyser.getByteFrequencyData(dataArray);

                    canvasCtx.fillStyle = '#f0f2f5';
                    canvasCtx.fillRect(0, 0, this.micVisualizer.width, this.micVisualizer.height);

                    const barWidth = (this.micVisualizer.width / bufferLength) * 2.5;
                    let barHeight;
                    let x = 0;

                    for (let i = 0; i < bufferLength; i++) {
                        barHeight = dataArray[i] / 2;
                        canvasCtx.fillStyle = `rgb(102, 126, 234, ${barHeight / 100})`;
                        canvasCtx.fillRect(x, this.micVisualizer.height - barHeight, barWidth, barHeight);
                        x += barWidth + 1;
                    }
                };

                draw();
            }

            selectBestMimeType() {
                const format = this.recordingFormat.value;

                const webmTypes = [
                    'video/webm;codecs=vp9,opus',
                    'video/webm;codecs=vp8,opus',
                    'video/webm;codecs=h264,opus',
                    'video/webm'
                ];

                const mp4Types = [
                    'video/mp4;codecs=h264,aac',
                    'video/mp4'
                ];

                const typesToTest = (format === 'mp4') ? mp4Types : webmTypes;

                for (const type of typesToTest) {
                    if (MediaRecorder.isTypeSupported(type)) {
                        return type;
                    }
                }

                // Fallback if the chosen format has no supported mime types
                if (format === 'mp4') {
                    this.showWarning('MP4 recording not supported, falling back to WebM.');
                    this.recordingFormat.value = 'webm';
                    // Try webm types
                    return webmTypes.find(type => MediaRecorder.isTypeSupported(type)) || '';
                }

                return ''; // Should not happen if WebM is supported
            }

            pauseRecording() {
                if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
                    this.mediaRecorder.pause();
                    this.stopTimer();
                    this.updateStatus('⏸️ Recording Paused', 'paused');
                    this.pauseBtn.style.display = 'none';
                    this.resumeBtn.style.display = 'inline-block';
                }
            }

            resumeRecording() {
                if (this.mediaRecorder && this.mediaRecorder.state === 'paused') {
                    this.mediaRecorder.resume();
                    this.startTimer();
                    this.updateStatus('🔴 Recording in progress...', 'recording');
                    this.pauseBtn.style.display = 'inline-block';
                    this.resumeBtn.style.display = 'none';
                }
            }


            stopRecording() {
                if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                    this.mediaRecorder.stop(); // This will trigger the 'onstop' event handler
                    this.stopTimer();
                    this.updateStatus('⏹️ Processing video...', 'stopped');
                }
            }

            handleStop() {
                const mimeType = (this.mediaRecorder && this.mediaRecorder.mimeType) || 'video/webm';
                this.recordedBlob = new Blob(this.chunks, { type: mimeType });
                const url = URL.createObjectURL(this.recordedBlob);
                this.previewVideo.src = url;
                const sizeMB = (this.recordedBlob.size / (1024 * 1024)).toFixed(2);
                const isMp4 = mimeType.includes('mp4');
                const format = isMp4 ? 'MP4' : 'WebM';
                this.fileInfo.textContent = `File size: ${sizeMB} MB | Format: ${format} | Quality: ${this.videoQuality.value} @ ${this.frameRate.value}fps`;
                if (isMp4) {
                    this.downloadBtn.textContent = 'Download MP4';
                    this.convertBtn.style.display = 'none';
                } else {
                    this.downloadBtn.textContent = 'Download WebM';
                    this.convertBtn.style.display = this.ffmpeg ? 'inline-block' : 'none';
                }
                this.previewContainer.style.display = 'block';
                this.updateStatus('✅ Recording complete', 'ready');
                this.enableUIIdle();
                this.cleanup();
            }

            async convertAndDownload() {
                if (!this.recordedBlob || !this.ffmpeg) {
                    this.showError('Conversion not available or no recording found.');
                    return;
                }

                try {
                    this.conversionProgress.style.display = 'block';
                    this.convertBtn.disabled = true;

                    // Load FFmpeg if not already loaded
                    if (!this.ffmpeg.isLoaded()) {
                        this.updateProgress('Loading FFmpeg...', 10);
                        await this.ffmpeg.load();
                    }

                    this.updateProgress('Preparing file...', 30);

                    // Write input file
                    const inputName = 'input.webm';
                    const outputName = 'output.mp4';
                    this.ffmpeg.FS('writeFile', inputName, await this.fetchFile(this.recordedBlob));

                    this.updateProgress('Converting to MP4...', 50);

                    // Convert with high quality settings
                    await this.ffmpeg.run(
                        '-i', inputName,
                        '-c:v', 'libx264',
                        '-preset', 'medium',
                        '-crf', '18',
                        '-c:a', 'aac',
                        '-b:a', '256k',
                        '-movflags', 'faststart',
                        outputName
                    );

                    this.updateProgress('Finalizing...', 90);

                    // Read output file
                    const data = this.ffmpeg.FS('readFile', outputName);
                    const mp4Blob = new Blob([data.buffer], { type: 'video/mp4' });

                    // Download
                    this.downloadBlob(mp4Blob, 'mp4');

                    // Cleanup FFmpeg files
                    this.ffmpeg.FS('unlink', inputName);
                    this.ffmpeg.FS('unlink', outputName);

                    this.updateProgress('Complete!', 100);
                    setTimeout(() => {
                        this.conversionProgress.style.display = 'none';
                        this.convertBtn.disabled = false;
                    }, 2000);

                } catch (err) {
                    this.showError('Conversion failed: ' + err.message);
                    this.conversionProgress.style.display = 'none';
                    this.convertBtn.disabled = false;
                }
            }

            async fetchFile(blob) {
                return new Uint8Array(await blob.arrayBuffer());
            }

            updateProgress(text, percent) {
                this.progressText.textContent = text + ` (${percent}%)`;
                this.progressFill.style.width = percent + '%';
            }

            downloadRecording(extension) {
                if (!this.recordedBlob) return;
                this.downloadBlob(this.recordedBlob, extension);
            }

            downloadBlob(blob, extension) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                a.href = url;
                a.download = `screen-recording-${timestamp}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    this.elapsedTimeInSeconds++;
                    const mm = String(Math.floor(this.elapsedTimeInSeconds / 60)).padStart(2, '0');
                    const ss = String(this.elapsedTimeInSeconds % 60).padStart(2, '0');
                    this.timer.textContent = `${mm}:${ss}`;
                }, 1000);
            }

            stopTimer() {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }

            updateStatus(text, className) {
                this.status.textContent = text;
                this.status.className = 'status ' + className;
            }

            disableUIOnStart() {
                this.startBtn.style.display = 'none';
                this.stopBtn.style.display = 'inline-block';
                this.pauseBtn.style.display = 'inline-block';
                this.resumeBtn.style.display = 'none';
                this.previewContainer.style.display = 'none';
            }

            enableUIIdle() {
                this.startBtn.style.display = 'inline-block';
                this.startBtn.disabled = false;
                this.stopBtn.style.display = 'none';
                this.pauseBtn.style.display = 'none';
                this.resumeBtn.style.display = 'none';


            }

            showError(message) {
                this.errorMessage.textContent = message;
                this.errorMessage.style.display = 'block';
                setTimeout(() => this.hideMessages(), 8000);
            }

            showWarning(message) {
                this.warningMessage.textContent = message;
                this.warningMessage.style.display = 'block';
                setTimeout(() => this.hideMessages(), 6000);
            }

            showDeviceInfo(message) {
                this.deviceInfo.textContent = message;
                this.deviceInfo.style.display = 'block';
            }

            hideMessages() {
                this.errorMessage.style.display = 'none';
                this.warningMessage.style.display = 'none';
            }

            cleanup() {
                try {
                    if (this.displayStream) {
                        this.displayStream.getTracks().forEach(track => track.stop());
                        this.displayStream = null;
                    }
                    if (this.micStream) {
                        this.micStream.getTracks().forEach(track => track.stop());
                        this.micStream = null;
                    }
                    if (this.audioCtx && this.audioCtx.state !== 'closed') {
                        this.audioCtx.close();
                        this.audioCtx = null;
                    }
                } catch (err) {
                    console.warn('Cleanup error:', err);
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new ScreenRecorderPro();
        });
    </script>
</body>

</html>